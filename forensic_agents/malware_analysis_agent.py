#!/usr/bin/env python3
"""
Malware Analysis Agent
Advanced malware detection and analysis with ML-based classification
"""

import asyncio
import hashlib
import re
import json
import base64
import binascii
from datetime import datetime, timezone
from typing import Dict, List, Any, Set, Tuple, Optional
import uuid
import math
import struct

from forensic_framework import ForensicAgent, Evidence, Finding

class MalwareAnalysisAgent(ForensicAgent):
    """Advanced malware analysis and detection agent"""
    
    def __init__(self):
        super().__init__("malware_analysis", "Malware Analysis Agent")
        self.known_malware_hashes: Set[str] = set()
        self.suspicious_strings: Set[str] = set()
        self.packer_signatures: Dict[str, str] = {}
        self.behavioral_patterns: Dict[str, List[str]] = {}
        self.yara_rules: List[Dict[str, Any]] = []
        
    async def initialize(self) -> bool:
        """Initialize the malware analysis agent"""
        try:
            # Load malware signatures and patterns
            await self.load_malware_signatures()
            await self.load_behavioral_patterns()
            await self.load_yara_rules()
            
            self.logger.info("Malware Analysis Agent initialized successfully")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to initialize Malware Analysis Agent: {e}")
            return False
    
    async def load_malware_signatures(self):
        """Load known malware hash signatures"""
        # Simulated malware hash database
        self.known_malware_hashes.update([
            "d41d8cd98f00b204e9800998ecf8427e",  # Empty file (test)
            "5d41402abc4b2a76b9719d911017c592",  # "hello" MD5
            "098f6bcd4621d373cade4e832627b4f6",  # "test" MD5
            "44d88612fea8a8f36de82e1278abb02f",  # Example malware hash
            "e99a18c428cb38d5f260853678922e03"   # Another example hash
        ])
        
        # Load suspicious strings commonly found in malware
        self.suspicious_strings.update([
            "CreateRemoteThread", "VirtualAllocEx", "WriteProcessMemory",
            "SetWindowsHookEx", "GetProcAddress", "LoadLibrary",
            "RegCreateKey", "RegSetValue", "ShellExecute",
            "WinExec", "CreateProcess", "TerminateProcess",
            "FindWindow", "FindNextFile", "CopyFile",
            "DeleteFile", "MoveFile", "GetSystemDirectory",
            "GetWindowsDirectory", "GetTempPath", "InternetOpen",
            "InternetConnect", "HttpOpenRequest", "HttpSendRequest",
            "FtpPutFile", "FtpGetFile", "socket", "connect",
            "send", "recv", "WSAStartup", "gethostbyname",
            "keylogger", "backdoor", "rootkit", "trojan",
            "virus", "worm", "botnet", "c2", "command"
        ])
        
        # Load packer signatures
        self.packer_signatures.update({
            "UPX": "555058",  # UPX header
            "Themida": "68????????E8????????",
            "VMProtect": "9C60E8????????",
            "ASPack": "60E8????????5D",
            "PECompact": "B8????????50"
        })
        
        self.logger.info(f"Loaded {len(self.known_malware_hashes)} malware signatures")
    
    async def load_behavioral_patterns(self):
        """Load behavioral analysis patterns"""
        self.behavioral_patterns = {
            "persistence": [
                "Registry\\Run", "Registry\\RunOnce", "Startup folder",
                "Service creation", "Scheduled task", "WMI subscription"
            ],
            "privilege_escalation": [
                "UAC bypass", "Token manipulation", "Process injection",
                "DLL hijacking", "Exploitation", "Kernel exploit"
            ],
            "defense_evasion": [
                "Process hollowing", "DLL injection", "Code injection",
                "Anti-debugging", "Anti-VM", "Obfuscation", "Packing"
            ],
            "credential_access": [
                "Credential dumping", "Keylogging", "Password cracking",
                "Browser password theft", "Memory scraping"
            ],
            "discovery": [
                "System enumeration", "Network enumeration", "File enumeration",
                "Process enumeration", "Service enumeration"
            ],
            "lateral_movement": [
                "Remote execution", "Credential reuse", "SMB/Admin shares",
                "RDP", "WMI", "PowerShell remoting"
            ],
            "collection": [
                "Data collection", "Screen capture", "Audio capture",
                "Clipboard data", "Browser data", "File collection"
            ],
            "exfiltration": [
                "Data compression", "Data encryption", "Network transfer",
                "Removable media", "Cloud storage", "DNS tunneling"
            ],
            "command_control": [
                "HTTP C2", "HTTPS C2", "DNS C2", "IRC C2",
                "P2P C2", "Social media C2", "Dead drop"
            ]
        }
        
        self.logger.info(f"Loaded {len(self.behavioral_patterns)} behavioral pattern categories")
    
    async def load_yara_rules(self):
        """Load YARA-like detection rules"""
        self.yara_rules = [
            {
                "name": "Suspicious_API_Calls",
                "description": "Detects suspicious API call patterns",
                "patterns": [
                    r"CreateRemoteThread.*VirtualAllocEx",
                    r"WriteProcessMemory.*CreateRemoteThread",
                    r"SetWindowsHookEx.*GetProcAddress"
                ],
                "severity": "HIGH"
            },
            {
                "name": "Ransomware_Indicators",
                "description": "Detects ransomware-like behavior",
                "patterns": [
                    r"\.encrypt|\.locked|\.crypto",
                    r"bitcoin|ransom|decrypt|payment",
                    r"CryptEncrypt.*DeleteFile"
                ],
                "severity": "CRITICAL"
            },
            {
                "name": "Keylogger_Patterns",
                "description": "Detects keylogger behavior",
                "patterns": [
                    r"GetAsyncKeyState|GetKeyState",
                    r"SetWindowsHookEx.*WH_KEYBOARD",
                    r"keylog|keystroke|password"
                ],
                "severity": "HIGH"
            },
            {
                "name": "Network_Backdoor",
                "description": "Detects network backdoor patterns",
                "patterns": [
                    r"socket.*bind.*listen",
                    r"CreateThread.*accept",
                    r"cmd\.exe.*pipe"
                ],
                "severity": "HIGH"
            }
        ]
        
        self.logger.info(f"Loaded {len(self.yara_rules)} YARA-like rules")
    
    async def analyze(self, evidence: Evidence) -> List[Finding]:
        """Analyze evidence for malware indicators"""
        findings = []
        
        if evidence.type not in ['file', 'process', 'memory_dump', 'network_traffic', 'registry_entry']:
            return findings
        
        try:
            # Static analysis
            static_findings = await self.static_analysis(evidence)
            findings.extend(static_findings)
            
            # Behavioral analysis
            behavioral_findings = await self.behavioral_analysis(evidence)
            findings.extend(behavioral_findings)
            
            # Signature-based detection
            signature_findings = await self.signature_detection(evidence)
            findings.extend(signature_findings)
            
            # Entropy analysis
            entropy_findings = await self.entropy_analysis(evidence)
            findings.extend(entropy_findings)
            
            # String analysis
            string_findings = await self.string_analysis(evidence)
            findings.extend(string_findings)
            
        except Exception as e:
            self.logger.error(f"Error analyzing evidence for malware: {e}")
        
        return findings
    
    async def static_analysis(self, evidence: Evidence) -> List[Finding]:
        """Perform static analysis on files"""
        findings = []
        
        if evidence.type != 'file':
            return findings
        
        data = evidence.data
        file_content = data.get('content', '')
        file_path = data.get('path', '')
        file_hash = data.get('hash', '')
        
        # Check against known malware hashes
        if file_hash in self.known_malware_hashes:
            finding = Finding(
                id=str(uuid.uuid4()),
                timestamp=datetime.now(timezone.utc),
                agent_id=self.agent_id,
                severity="CRITICAL",
                category="Known Malware",
                title="Known Malware Hash Detected",
                description=f"File {file_path} matches known malware hash {file_hash}",
                evidence_ids=[evidence.id],
                confidence=0.95,
                recommendations=[
                    f"Immediately quarantine file {file_path}",
                    "Scan entire system for related malware",
                    "Check for lateral movement from this host",
                    "Review process execution history"
                ]
            )
            findings.append(finding)
        
        # PE file analysis
        if file_content and self.is_pe_file(file_content):
            pe_findings = await self.analyze_pe_file(evidence, file_content)
            findings.extend(pe_findings)
        
        # Check for packers
        packer_findings = await self.detect_packers(evidence, file_content)
        findings.extend(packer_findings)
        
        return findings
    
    def is_pe_file(self, content: str) -> bool:
        """Check if content represents a PE file"""
        try:
            # Check for PE signature
            if isinstance(content, str):
                content = content.encode('latin-1')
            
            if len(content) < 64:
                return False
            
            # Check DOS header
            if content[:2] != b'MZ':
                return False
            
            # Get PE header offset
            pe_offset = struct.unpack('<I', content[60:64])[0]
            
            if pe_offset >= len(content) - 4:
                return False
            
            # Check PE signature
            return content[pe_offset:pe_offset+4] == b'PE\x00\x00'
            
        except:
            return False
    
    async def analyze_pe_file(self, evidence: Evidence, content: str) -> List[Finding]:
        """Analyze PE file structure"""
        findings = []
        
        try:
            if isinstance(content, str):
                content = content.encode('latin-1')
            
            # Get DOS header
            dos_header = content[:64]
            pe_offset = struct.unpack('<I', dos_header[60:64])[0]
            
            # Get PE header
            pe_header = content[pe_offset:pe_offset+24]
            coff_header = pe_header[4:24]
            
            # Extract basic information
            machine = struct.unpack('<H', coff_header[0:2])[0]
            num_sections = struct.unpack('<H', coff_header[2:4])[0]
            timestamp = struct.unpack('<I', coff_header[4:8])[0]
            
            # Check for suspicious characteristics
            if num_sections == 0:
                finding = Finding(
                    id=str(uuid.uuid4()),
                    timestamp=datetime.now(timezone.utc),
                    agent_id=self.agent_id,
                    severity="MEDIUM",
                    category="Suspicious PE",
                    title="PE File with Zero Sections",
                    description="PE file has zero sections, which is unusual and may indicate malware",
                    evidence_ids=[evidence.id],
                    confidence=0.70,
                    recommendations=[
                        "Analyze PE file structure in detail",
                        "Check for packed or obfuscated code",
                        "Review file behavior in sandbox"
                    ]
                )
                findings.append(finding)
            
            # Check compilation timestamp
            compile_time = datetime.fromtimestamp(timestamp, timezone.utc)
            now = datetime.now(timezone.utc)
            
            if compile_time > now:
                finding = Finding(
                    id=str(uuid.uuid4()),
                    timestamp=datetime.now(timezone.utc),
                    agent_id=self.agent_id,
                    severity="MEDIUM",
                    category="Suspicious PE",
                    title="Future Compilation Timestamp",
                    description=f"PE file has future compilation timestamp: {compile_time}",
                    evidence_ids=[evidence.id],
                    confidence=0.65,
                    recommendations=[
                        "Verify file authenticity",
                        "Check for timestamp manipulation",
                        "Analyze file for other anomalies"
                    ]
                )
                findings.append(finding)
            
        except Exception as e:
            self.logger.error(f"Error analyzing PE file: {e}")
        
        return findings
    
    async def detect_packers(self, evidence: Evidence, content: str) -> List[Finding]:
        """Detect packed executables"""
        findings = []
        
        if not content:
            return findings
        
        try:
            # Convert to hex string for pattern matching
            if isinstance(content, str):
                hex_content = content.encode('latin-1').hex().upper()
            else:
                hex_content = content.hex().upper()
            
            for packer_name, signature in self.packer_signatures.items():
                if signature in hex_content:
                    finding = Finding(
                        id=str(uuid.uuid4()),
                        timestamp=datetime.now(timezone.utc),
                        agent_id=self.agent_id,
                        severity="MEDIUM",
                        category="Packed Executable",
                        title=f"{packer_name} Packer Detected",
                        description=f"File appears to be packed with {packer_name}, "
                                   f"which may indicate malware obfuscation",
                        evidence_ids=[evidence.id],
                        confidence=0.75,
                        recommendations=[
                            f"Unpack file using {packer_name} tools",
                            "Analyze unpacked code for malicious behavior",
                            "Check why legitimate software would be packed",
                            "Review file origin and distribution method"
                        ]
                    )
                    findings.append(finding)
            
        except Exception as e:
            self.logger.error(f"Error detecting packers: {e}")
        
        return findings
    
    async def behavioral_analysis(self, evidence: Evidence) -> List[Finding]:
        """Analyze behavioral patterns"""
        findings = []
        
        if evidence.type not in ['process', 'registry_entry', 'file']:
            return findings
        
        data = evidence.data
        
        # Analyze process behavior
        if evidence.type == 'process':
            process_findings = await self.analyze_process_behavior(evidence, data)
            findings.extend(process_findings)
        
        # Analyze registry modifications
        if evidence.type == 'registry_entry':
            registry_findings = await self.analyze_registry_behavior(evidence, data)
            findings.extend(registry_findings)
        
        return findings
    
    async def analyze_process_behavior(self, evidence: Evidence, data: Dict[str, Any]) -> List[Finding]:
        """Analyze process behavior patterns"""
        findings = []
        
        process_name = data.get('name', '')
        command_line = data.get('command_line', '')
        parent_process = data.get('parent_process', '')
        
        # Check for suspicious process relationships
        suspicious_relationships = [
            ('winword.exe', 'cmd.exe'),
            ('excel.exe', 'powershell.exe'),
            ('acrobat.exe', 'cmd.exe'),
            ('explorer.exe', 'powershell.exe'),
            ('svchost.exe', 'cmd.exe')
        ]
        
        for parent, child in suspicious_relationships:
            if parent.lower() in parent_process.lower() and child.lower() in process_name.lower():
                finding = Finding(
                    id=str(uuid.uuid4()),
                    timestamp=datetime.now(timezone.utc),
                    agent_id=self.agent_id,
                    severity="HIGH",
                    category="Suspicious Process",
                    title="Suspicious Parent-Child Process Relationship",
                    description=f"Suspicious process relationship: {parent} spawned {child}",
                    evidence_ids=[evidence.id],
                    confidence=0.80,
                    recommendations=[
                        f"Investigate process {child} for malicious activity",
                        f"Check if {parent} was compromised",
                        "Review command line arguments",
                        "Analyze process memory for injected code"
                    ]
                )
                findings.append(finding)
        
        # Check command line for suspicious patterns
        suspicious_cmdline_patterns = [
            r'powershell.*-enc.*',  # Encoded PowerShell
            r'cmd.*\/c.*echo.*',    # Command execution
            r'wmic.*process.*call.*create',  # WMIC process creation
            r'reg.*add.*HKLM.*Run',  # Registry persistence
            r'schtasks.*\/create',   # Scheduled task creation
            r'net.*user.*\/add',     # User creation
            r'vssadmin.*delete.*shadows'  # Shadow copy deletion
        ]
        
        for pattern in suspicious_cmdline_patterns:
            if re.search(pattern, command_line, re.IGNORECASE):
                finding = Finding(
                    id=str(uuid.uuid4()),
                    timestamp=datetime.now(timezone.utc),
                    agent_id=self.agent_id,
                    severity="HIGH",
                    category="Suspicious Command",
                    title="Suspicious Command Line Pattern",
                    description=f"Process {process_name} executed suspicious command: {command_line[:100]}...",
                    evidence_ids=[evidence.id],
                    confidence=0.75,
                    recommendations=[
                        "Analyze full command line for malicious intent",
                        "Check process for code injection",
                        "Review parent process for compromise",
                        "Monitor for additional suspicious activity"
                    ]
                )
                findings.append(finding)
        
        return findings
    
    async def analyze_registry_behavior(self, evidence: Evidence, data: Dict[str, Any]) -> List[Finding]:
        """Analyze registry modification patterns"""
        findings = []
        
        registry_key = data.get('key', '')
        registry_value = data.get('value', '')
        operation = data.get('operation', '')
        
        # Check for persistence mechanisms
        persistence_keys = [
            r'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run',
            r'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce',
            r'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunServices',
            r'SYSTEM\\CurrentControlSet\\Services'
        ]
        
        for persist_key in persistence_keys:
            if persist_key.lower() in registry_key.lower() and operation.lower() == 'create':
                finding = Finding(
                    id=str(uuid.uuid4()),
                    timestamp=datetime.now(timezone.utc),
                    agent_id=self.agent_id,
                    severity="MEDIUM",
                    category="Persistence Mechanism",
                    title="Registry Persistence Mechanism",
                    description=f"Registry key {registry_key} was created for persistence",
                    evidence_ids=[evidence.id],
                    confidence=0.70,
                    recommendations=[
                        f"Investigate program referenced in {registry_key}",
                        "Check if persistence mechanism is legitimate",
                        "Review other persistence indicators",
                        "Monitor for additional malicious activity"
                    ]
                )
                findings.append(finding)
        
        return findings
    
    async def signature_detection(self, evidence: Evidence) -> List[Finding]:
        """Apply YARA-like rules for signature detection"""
        findings = []
        
        data = evidence.data
        content = str(data.get('content', '')) + str(data.get('command_line', '')) + str(data.get('value', ''))
        
        if not content:
            return findings
        
        for rule in self.yara_rules:
            for pattern in rule['patterns']:
                if re.search(pattern, content, re.IGNORECASE):
                    finding = Finding(
                        id=str(uuid.uuid4()),
                        timestamp=datetime.now(timezone.utc),
                        agent_id=self.agent_id,
                        severity=rule['severity'],
                        category="Signature Detection",
                        title=f"YARA Rule Match: {rule['name']}",
                        description=f"{rule['description']} - Pattern matched: {pattern[:50]}...",
                        evidence_ids=[evidence.id],
                        confidence=0.80,
                        recommendations=[
                            "Investigate matched content in detail",
                            "Check for additional indicators",
                            "Review file/process behavior",
                            "Consider quarantine if confirmed malicious"
                        ]
                    )
                    findings.append(finding)
        
        return findings
    
    async def entropy_analysis(self, evidence: Evidence) -> List[Finding]:
        """Analyze file entropy for packed/encrypted content"""
        findings = []
        
        if evidence.type != 'file':
            return findings
        
        content = evidence.data.get('content', '')
        if not content:
            return findings
        
        try:
            # Calculate Shannon entropy
            entropy = self.calculate_entropy(content)
            
            # High entropy may indicate packed/encrypted content
            if entropy > 7.5:  # Threshold for suspicious entropy
                finding = Finding(
                    id=str(uuid.uuid4()),
                    timestamp=datetime.now(timezone.utc),
                    agent_id=self.agent_id,
                    severity="MEDIUM",
                    category="High Entropy",
                    title="High File Entropy Detected",
                    description=f"File has high entropy ({entropy:.2f}), indicating possible "
                               f"packing, encryption, or obfuscation",
                    evidence_ids=[evidence.id],
                    confidence=0.65,
                    recommendations=[
                        "Check if file is legitimately packed/compressed",
                        "Attempt to unpack or decrypt content",
                        "Analyze file for malware indicators",
                        "Review file origin and purpose"
                    ]
                )
                findings.append(finding)
                
        except Exception as e:
            self.logger.error(f"Error calculating entropy: {e}")
        
        return findings
    
    def calculate_entropy(self, data: str) -> float:
        """Calculate Shannon entropy of data"""
        if not data:
            return 0
        
        # Count frequency of each byte
        frequencies = {}
        for byte in data:
            frequencies[byte] = frequencies.get(byte, 0) + 1
        
        # Calculate entropy
        entropy = 0
        data_len = len(data)
        
        for count in frequencies.values():
            probability = count / data_len
            if probability > 0:
                entropy -= probability * math.log2(probability)
        
        return entropy
    
    async def string_analysis(self, evidence: Evidence) -> List[Finding]:
        """Analyze strings for suspicious content"""
        findings = []
        
        content = str(evidence.data.get('content', ''))
        if not content:
            return findings
        
        # Extract printable strings
        strings = re.findall(r'[!-~]{4,}', content)
        
        suspicious_count = 0
        matched_strings = []
        
        for string in strings:
            for suspicious_string in self.suspicious_strings:
                if suspicious_string.lower() in string.lower():
                    suspicious_count += 1
                    matched_strings.append(string)
                    break
        
        if suspicious_count >= 3:  # Threshold for suspicious string count
            finding = Finding(
                id=str(uuid.uuid4()),
                timestamp=datetime.now(timezone.utc),
                agent_id=self.agent_id,
                severity="MEDIUM",
                category="Suspicious Strings",
                title="Multiple Suspicious Strings Detected",
                description=f"Found {suspicious_count} suspicious strings in file, "
                           f"including: {', '.join(matched_strings[:5])}",
                evidence_ids=[evidence.id],
                confidence=0.70,
                recommendations=[
                    "Analyze all suspicious strings in context",
                    "Check if strings indicate malicious functionality",
                    "Review file behavior and purpose",
                    "Consider dynamic analysis in sandbox"
                ]
            )
            findings.append(finding)
        
        return findings